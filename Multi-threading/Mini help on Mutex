lock – если мьютекс не принадлежит никакому потоку, тогда поток, вызвавший lock, становится его обладателем. Если же некий поток уже владеет мьютексом, то текущий поток(который пытается овладеть им) блокируется до тех пор, пока мьютекс не будет освобожден и у него не появится шанса овладеть им.

try_lock - если мьютекс не принадлежит никакому потоку, тогда поток, вызвавший try_lock, становится его обладателем и метод возвращает true. В противном случае возвращает false. try_lock не блокирует текущий поток.

unlock – освобождает ранее захваченный мьютекс.

#2 дополнительные для временных(timed) мьютексов:

try_lock_for – расширенная версия try_lock, которая позволяет задать продолжительность ожидания, прежде чем стоит прекратить попытку овладения мьютексом. Т.е. возвращает true в том случае, если удалось овладеть мьютексом в заданный промежуток времени. В противном случае возвращает false. Принимает std::chrono::duration, в качестве аргумента.

try_lock_until – та же, что предыдущая, но принимает std::chrono::time_point в качестве аргумента.

#4 типа mutex:

std::mutex – базовый mutex, которым может владеть один поток в единицу времени. При попытке повторного овладения мьютексом, потоком, уже владеющим им, произойдёт deadlock(или будет брошено исключение с кодом ошибки  resource_deadlock_would_occur). 

std::recursive_mutex – обладает теми же свойствами, что и std::mutex, но позволяет рекурсивное овладение мьютексом, то есть многократный вызов метода lock() в потоке, который владеет мьютексом. При этом, метод unlock() должен быть вызван не меньшее количество раз, чем был вызван lock(). В противном случае вы получите deadlock, т.к. этот поток никогда не освободит мьютекс и остальные потоки будут находиться в вечном ожидании.

std::timed_mutex – обладая свойствами std::mutex, std::timed_mutex, так же, обладает дополнительными методами позволяющими блокировку на время.

std::recursive_timed_mutex – рекуррентная версия std::timed_mutex.
